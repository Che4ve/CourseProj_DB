# Полное руководство по защите курсового проекта "Информационная система для трекинга привычек"

Этот документ содержит всю необходимую информацию для ответов на вопросы по отчету. Он основан на файле `report/main.tex` и актуальном состоянии базы данных.

## 1. Общая информация о проекте

*   **Тема:** Информационная система для трекинга привычек (Habit Tracker).
*   **Цель:** Проектирование и реализация полнофункциональной реляционной БД, интегрированной с серверным API для учета привычек, аналитики и аудита.
*   **Стек технологий:**
    *   **СУБД:** PostgreSQL 16.
    *   **Backend:** NestJS + Prisma ORM.
    *   **Frontend:** Next.js (в отчете упоминается как часть архитектуры, но фокус на БД).
    *   **Инфраструктура:** Docker, Docker Compose.
*   **Результаты:** 13 таблиц, триггеры, хранимые функции, представления, API, Batch Import.

---

## 2. Структура Базы Данных (13 таблиц)

База данных спроектирована в 3-й нормальной форме (3НФ).

### Основные сущности

1.  **`users` (Пользователи)**
    *   **Назначение:** Хранение учетных данных.
    *   **Ключевые поля:** `id` (UUID), `email` (Unique), `password_hash`, `role` (user/admin).
    *   **Особенности:** Поле `is_active` для мягкого бана.

2.  **`user_profiles` (Профили)**
    *   **Назначение:** Расширенная информация о пользователе.
    *   **Связь:** 1:1 с `users`.
    *   **Поля:** `bio`, `timezone` (для уведомлений), `theme_preference` (настройки UI).

3.  **`habits` (Привычки)**
    *   **Назначение:** Центральная сущность. Хранит сами привычки.
    *   **Связь:** M:1 с `users` (у пользователя много привычек).
    *   **Поля:** `type` ('good'/'bad'), `priority` (0-10), `is_archived`.

4.  **`habit_schedules` (Расписания)**
    *   **Назначение:** Настройка частоты выполнения привычки.
    *   **Связь:** M:1 с `habits`.
    *   **Поля:** `frequency_type` (daily/weekly), `weekdays_mask` (битовая маска дней, например 127 = все дни).

5.  **`habit_checkins` (Отметки/Чекины)**
    *   **Назначение:** Факт выполнения привычки.
    *   **Связь:** M:1 с `habits`.
    *   **Поля:** `checkin_date`, `mood_rating` (1-5), `notes`.
    *   **Ограничение:** Уникальный индекс на `(habit_id, checkin_date)` — нельзя отметить одну привычку дважды за день.

### Вспомогательные сущности и классификация

6.  **`tags` (Теги)**
    *   **Назначение:** Глобальный справочник тегов.
    *   **Поля:** `name`, `slug`, `color`.

7.  **`habit_tags` (Связь привычек и тегов)**
    *   **Назначение:** Реализация связи "Многие-ко-многим" (N:M) между `habits` и `tags`.
    *   **Поля:** `is_primary` (флаг основного тега).

8.  **`reminders` (Напоминания)**
    *   **Назначение:** Время уведомлений.
    *   **Связь:** M:1 с `habits`.
    *   **Поля:** `reminder_time` (TIME), `days_of_week`.

### Аналитика и Аудит

9.  **`habit_stats` (Агрегированная статистика)**
    *   **Назначение:** Кеширование статистики для быстрого доступа (денормализация для чтения).
    *   **Связь:** 1:1 с `habits`.
    *   **Поля:** `total_checkins`, `current_streak`, `completion_rate`.
    *   **Зачем:** Чтобы не считать `COUNT(*)` при каждом запросе списка привычек. Обновляется триггером.

10. **`audit_log` (Журнал аудита)**
    *   **Назначение:** История изменений важных данных.
    *   **Поля:** `table_name` (TEXT), `operation` (INSERT/UPDATE/DELETE), `old_data` (JSONB), `new_data` (JSONB), `ip_address` (TEXT).
    *   **Особенность:** Заполняется автоматически триггерами.

### Служебные таблицы

11. **`batch_import_jobs`**: Статус задач массового импорта.
12. **`batch_import_errors`**: Ошибки при импорте (невалидные строки).
13. **`_manual_migrations`**: Учет накатанных SQL-миграций.

---

## 3. Бизнес-логика на стороне СУБД (SQL Objects)

В проекте часть логики вынесена в базу для надежности и скорости.

### Триггеры (Triggers)

1.  **Аудит (`audit_trigger_fn`)**
    *   **Где висит:** На таблицах `habits`, `habit_checkins`, `tags`, `reminders`.
    *   **Что делает:** При любом INSERT/UPDATE/DELETE пишет запись в `audit_log`. Сохраняет старое и новое состояние записи в JSONB.
    *   **Зачем:** Безопасность, разбор инцидентов, история изменений.

2.  **Обновление статистики (`update_habit_stats`)**
    *   **Где висит:** На таблице `habit_checkins`.
    *   **Что делает:** При добавлении/удалении чекина пересчитывает `total_checkins`, среднее настроение и дату последнего выполнения для привычки и пишет это в `habit_stats`.
    *   **Зачем:** Оптимизация чтения (Read-heavy optimization).

### Представления (Views)

*   **`v_daily_completion`**: Показывает активность по дням.
    *   Считает кол-во чекинов, активных пользователей и среднее настроение за каждый день.
    *   Используется для построения графиков на дашборде.

### Функции (Functions)

*   **`audit_trigger_fn()`**: Универсальная функция для триггеров аудита.
*   **`update_habit_stats()`**: Функция для триггера пересчета статистики.

---

## 4. Оптимизация и Индексы

### Стратегия индексации
Индексы созданы для полей, по которым часто идет поиск (`WHERE`) или соединение (`JOIN`).

1.  **Foreign Keys:** `user_id`, `habit_id` во всех таблицах. PostgreSQL не создает индексы на FK автоматически, это сделано вручную для ускорения `JOIN`.
2.  **Поиск:** `users(email)`, `tags(name)`.
3.  **Сортировка:** `audit_log(changed_at DESC)` — для быстрого показа последних логов.
4.  **Уникальность:** `(habit_id, checkin_date)` в чекинах.

### Результаты `EXPLAIN ANALYZE` (из отчета)
*   **История отметок:** Ускорение **~52x** (145мс -> 2.8мс) за счет индекса по `habit_id` + `checkin_date`.
*   **Журнал аудита:** Ускорение **~69x** (89мс -> 1.3мс) за счет индекса по `changed_at`.

---

## 5. Batch Import (Массовая загрузка)

**Проблема:** Нужно загрузить 10,000 записей (например, историю из другого приложения). Вставка по одной (`INSERT INTO ... VALUES`) очень медленная.

**Решение:**
1.  Пользователь грузит JSON/CSV.
2.  Создается задача в `batch_import_jobs`.
3.  Данные валидируются.
4.  Корректные записи вставляются транзакцией.
5.  Некорректные (ошибки формата, дубликаты) — пишутся в `batch_import_errors` с указанием номера строки и причины.
6.  **Итог:** Импорт не падает целиком из-за одной ошибки.

---

## 6. Ответы на частые вопросы (FAQ)

**В: Почему `TIMESTAMPTZ` без точности (6)?**
О: В PostgreSQL `TIMESTAMPTZ` по умолчанию хранит микросекунды (точность 6). Мы убрали явное указание `(6)` в схеме, чтобы использовать дефолтное поведение и упростить миграции, так как функционально это то же самое.

**В: Почему `ip_address` стал `TEXT`, а не `INET`?**
О: Тип `INET` специфичен для PostgreSQL. Использование `TEXT` (или `VARCHAR`) упрощает работу с ORM (Prisma) и делает схему более переносимой, при этом валидацию IP-адреса можно делать на уровне приложения (NestJS ValidationPipe).

**В: Зачем нужны триггеры, если есть backend?**
О: Триггеры гарантируют целостность данных *всегда*, даже если данные меняются прямым SQL-запросом администратора в обход API. Это последний рубеж защиты данных.

**В: Что такое JSONB и зачем он в аудите?**
О: `JSONB` — это бинарный формат хранения JSON в PostgreSQL. Он позволяет хранить слепок записи (всю строку целиком) в одном поле. Это идеально для аудита, так как структура разных таблиц разная, а `old_data`/`new_data` должны хранить всё. `JSONB` поддерживает индексацию и поиск внутри JSON.

**В: Почему `checkin_date` (DATE), а `checkin_time` (TIME) отдельно?**
О: Это разделение логическое. Привычка выполняется "в определенный день". Время — это дополнительная мета-информация. Это упрощает проверку уникальности "один раз в день" (индекс только по `checkin_date`).


