Ты работаешь в режиме PLAN в Cursor внутри существующего репозитория CourseProj.

Текущее состояние (важные факты из структуры проекта):
- Это Next.js приложение в корне репозитория: папки app/, components/, contexts/, lib/, public/, middleware.ts, next.config.ts, tsconfig.json.
- В lib/supabase есть client.ts и server.ts, и во фронте используются server actions в app/actions/*.ts, которые, вероятно, ходят в Supabase напрямую.
- Есть supabase-setup.sql (существующая схема/настройка БД в стиле Supabase).
- Есть файл Курсовая_работа_БД_2025.pdf в корне репозитория (требования курсовой).
- Есть __tests__/ и vitest конфиги. Их можно удалить полностью. GitLab CI/файлы тоже не нужны.

Цель:
Переделать проект под новый стек и требования курсовой:
- Monorepo: pnpm workspaces + Turborepo
- apps/frontend: текущий Next.js фронтенд (перенести как есть, но адаптировать data layer)
- apps/backend: новый backend на NestJS (TypeScript)
- packages/db: Prisma schema + миграции + seed + отдельные SQL-миграции для триггеров/VIEW/функций/индексов
- packages/shared (опционально): общие типы DTO/enum/валидации (если реально используется)
- База данных: PostgreSQL локально в docker-compose (Supabase как runtime зависимость убрать; можно оставить supabase-setup.sql как исторический артефакт/референс)
- ORM: Prisma для CRUD
- Сложные отчёты/агрегации: чистый SQL (JOIN/GROUP BY/подзапросы), строго параметризовано
- Swagger/OpenAPI на backend
- Триггеры аудита INSERT/UPDATE/DELETE + триггер агрегатов
- Функции: минимум 1 скалярная + 1 табличная
- VIEW: минимум 3
- Индексы + сравнение производительности через EXPLAIN ANALYZE (до/после), отчёт в docs/perf.md
- Batch import: /api/batch-import с логированием ошибок в таблицы
- Seed должен генерировать 5000+ записей в транзакционной таблице (например habit_checkins)
- docker-compose: db + backend + (frontend по желанию, но лучше включить)
- Никаких секретов в репозитории: только env и .env.example
- Запрещено строить SQL конкатенацией строк: только параметризация
- Тесты и CI не делать: __tests__/vitest/и любые pipeline файлы удалить, зависимости убрать.

Обязательное действие №0:
Открой Курсовая_работа_БД_2025.pdf и составь:
- точный чеклист требований (списком),
- и карту соответствия “требование -> где в проекте реализовано (файл/эндпойнт/миграция/SQL)”.
Эта карта должна быть оформлена в /docs/requirements-checklist.md.

Далее работай по шагам, маленькими логическими коммит-подобными изменениями (но без реальных коммитов):
каждый шаг: что меняешь, какие файлы, зачем, как проверить.

--------------------------------------------------------------------
ПЛАН РАБОТЫ (выдай подробный план, затем приступай к реализации):
--------------------------------------------------------------------

1) Аудит текущего проекта (без изменений кода)
   1.1. Найди где и как используется Supabase:
        - app/actions/authActions.ts
        - app/actions/habitActions.ts
        - app/actions/completionActions.ts
        - lib/supabase/client.ts и lib/supabase/server.ts
        - app/api/auth/callback/route.ts (если это supabase auth callback)
        - middleware.ts (возможно защита роутов)
   1.2. Составь список текущих пользовательских сценариев по UI:
        - login/signup (app/(auth)/login, signup)
        - dashboard (app/(dashboard)/page.tsx)
        - список привычек, создание/редактирование, отметки выполнения (components/habits/*)
   1.3. Зафиксируй текущие сущности и поля из кода (даже если Supabase типы в lib/databaseTypes.ts).
   1.4. Открой supabase-setup.sql и извлеки имеющуюся модель данных (таблицы/поля/связи), если она есть.
        Это будет “точка миграции” в новую Postgres схему.

2) Перевод в монорепу (pnpm + Turborepo)
   2.1. В корне репозитория создать:
        - pnpm-workspace.yaml
        - turbo.json
        - package.json (корневой, новый) с workspaces-скриптами
        - .npmrc (если нужно, например shamefully-hoist=false по умолчанию)
   2.2. Перенести текущий Next.js проект в apps/frontend:
        - переместить app/, components/, contexts/, lib/, public/, middleware.ts,
          next.config.ts, postcss.config.mjs, tsconfig.json, biome.json, components.json,
          env.example и прочие фронтовые файлы в apps/frontend
        - убедиться, что пути импорта не сломались (при необходимости настроить tsconfig paths)
   2.3. Удалить мусор, который нам не нужен:
        - удалить __tests__/ полностью
        - удалить vitest.config.ts и vitest.setup.ts
        - удалить зависимости vitest/testing-library и связанные скрипты из package.json фронта
        - удалить любые GitLab CI файлы, если они есть (.gitlab-ci.yml и т.п.)
   2.4. Перейти с npm на pnpm:
        - удалить package-lock.json
        - создать pnpm-lock.yaml после установки
   2.5. Настроить единые команды:
        - pnpm dev (запускает frontend + backend + возможно docker compose)
        - pnpm lint / pnpm typecheck
        - pnpm db:migrate / pnpm db:seed

3) packages/db: Prisma + SQL миграции для “базоданных”
   3.1. Создать packages/db:
        - prisma/schema.prisma
        - prisma/migrations/ (авто)
        - scripts/seed.ts
        - sql/ (ручные SQL-миграции: triggers.sql, views.sql, functions.sql, indexes.sql)
        - scripts/apply-sql-migrations.ts (аккуратно применяет SQL после prisma migrate)
   3.2. Спроектировать схему под требования курсовой (минимум 9–10 таблиц, каждая >=5 атрибутов разных типов,
        связи 1:1, 1:N, N:M, PK/FK/UNIQUE/CHECK/NOT NULL).
        Основа (адаптируй под текущий UI, но не ломай смысл):
        - users
        - user_profiles (1:1)
        - habits (1:N от users)
        - habit_schedules (1:N от habits)
        - habit_checkins (1:N, транзакционная таблица, тут будет 5000+ записей)
        - tags
        - habit_tags (N:M habits<->tags)
        - reminders (1:N)
        - habit_stats (агрегаты)
        - audit_log (аудит)
        - batch_import_jobs + batch_import_errors (если нужно для красивого batch-import)
   3.3. Портировать и/или вдохновиться supabase-setup.sql:
        - если там уже есть таблицы, адаптировать их в новую схему,
          но финальная схема должна соответствовать требованиям PDF.
   3.4. Seed:
        - генерировать пользователей, привычки, расписания, теги
        - создать 5000+ checkins (распределить по датам), чтобы было что индексировать и анализировать
        - убедиться, что seed воспроизводим (фиксированный random seed)

4) SQL-объекты: триггеры, аудит, агрегаты, функции, VIEW, индексы, EXPLAIN ANALYZE
   4.1. Аудит-триггер:
        - единая функция audit_trigger_fn() (PL/pgSQL) пишет в audit_log:
          table_name, operation, changed_at, user_id (если доступно), old_row JSONB, new_row JSONB
        - навесить AFTER INSERT/UPDATE/DELETE на ключевые таблицы (habits, habit_checkins, reminders, tags и т.д.)
   4.2. Триггер агрегатов:
        - при INSERT/DELETE habit_checkins обновлять habit_stats:
          completion_count, last_checkin_at, current_streak (можно упростить streak, но чтобы было логично)
   4.3. Функции:
        - скалярная: calc_completion_rate(p_user_id, p_from, p_to) returns numeric
        - табличная: report_user_habits(p_user_id, p_from, p_to) returns table(...)
   4.4. VIEW (минимум 3):
        - v_user_habit_summary
        - v_daily_completion
        - v_habit_streaks или v_tag_usage (на выбор)
   4.5. Индексы + perf отчёт:
        - определить минимум 2 “тяжёлых” запроса (например отчёт по checkins по периоду + join habits)
        - замерить EXPLAIN ANALYZE ДО индекса
        - добавить индекс (например habit_checkins(habit_id, checkin_date), habit_checkins(user_id, checkin_date))
        - замерить ПОСЛЕ индекса
        - оформить в /docs/perf.md (SQL + выводы)
   4.6. Важно: SQL должен быть отдельно виден в репо, а не “магически внутри ORM”.

5) apps/backend: NestJS API + Swagger + Prisma + JWT auth
   5.1. Создать NestJS проект в apps/backend (TypeScript).
   5.2. Подключить Prisma client из packages/db (единый источник).
   5.3. Конфиг:
        - dotenv
        - глобальная валидация DTO
        - CORS для фронта
        - централизованные ошибки (HttpException filter)
   5.4. Swagger:
        - /api/docs
        - описанные DTO и примеры
   5.5. Auth (без Supabase):
        - register/login/me
        - bcrypt для паролей
        - JWT access token (минимум)
        - guard для защищённых эндпойнтов
        - привязка данных к user_id
   5.6. CRUD эндпойнты:
        - habits, schedules, checkins, tags, reminders
   5.7. Транзакционный эндпойнт:
        - POST /habits/:id/checkins
          внутри транзакции: insert checkin + (опционально) обновление stats (или довериться триггеру, но транзакцию всё равно показать)
   5.8. Отчётные эндпойнты (чистый SQL, параметризовано):
        - GET /reports/user/:userId?from=...&to=...
        - использовать Prisma $queryRaw с параметрами (никакой склейки строк)
   5.9. Batch import:
        - POST /batch-import
          принимает JSON массив (CSV необязателен, но можно позже)
          валидирует, вставляет пачками, ошибки пишет в batch_import_errors,
          итоги в batch_import_jobs
   5.10. Проставить rate limit/helmet НЕ обязательно (не требование), не оверинженерить.

6) apps/frontend: адаптация Next.js под новый backend
   6.1. Полностью убрать прямой доступ к Supabase DB:
        - удалить/не использовать lib/supabase/client.ts и lib/supabase/server.ts для данных
        - app/actions/* переписать так, чтобы они вызывали backend API (fetch)
        - app/api/auth/callback/route.ts удалить или переписать (Supabase callback больше не нужен)
   6.2. Сделать API клиент:
        - apps/frontend/lib/api/client.ts (fetch wrapper)
        - типы DTO либо из packages/shared, либо локально (выбрать один путь, не смешивать)
   6.3. Auth на фронте:
        - формы LoginForm/SignupForm оставить UI, но отправлять на backend /auth/register и /auth/login
        - хранение токена:
          предпочтительно httpOnly cookie (если реализуешь на backend),
          иначе временно localStorage (но тогда отметь в docs/security-notes.md, что это компромисс)
        - middleware.ts адаптировать под новый способ авторизации (проверка cookie/токена через backend)
   6.4. Проверка сценариев:
        - регистрация/логин
        - dashboard: список привычек
        - создание привычки
        - отметка выполнения (checkin)
        - теги/расписания/напоминания (если есть UI, минимум базовый CRUD)

7) docker-compose и запуск “одной кнопкой”
   7.1. В корне создать docker-compose.yml:
        - db (postgres)
        - backend (NestJS)
        - frontend (Next)
        - volume для postgres
        - env файлы
   7.2. Порты:
        - db: 5432
        - backend: 3001 (например)
        - frontend: 3000
   7.3. Команды:
        - pnpm dev: локальная разработка (turbo)
        - pnpm docker:up / docker:down (опционально)
        - pnpm db:migrate, pnpm db:seed, pnpm db:sql (ручные SQL миграции)

8) Документация для курсовой (чтобы преподаватель не фантазировал)
   Создать папку /docs и файлы:
   - requirements-checklist.md (из PDF: пункт -> реализация)
   - schema.md (описание таблиц, связей, ограничения; ER diagram mermaid приветствуется)
   - api.md (как запустить, где Swagger, примеры запросов)
   - perf.md (EXPLAIN ANALYZE до/после индексов)
   - batch-import.md (формат, пример, как смотреть ошибки)
   - security-notes.md (где хранятся секреты, как устроена авторизация, почему нет supabase)
   Обновить README.md: быстрый старт, команды, структура монорепы.

--------------------------------------------------------------------
Definition of Done (без этого не считать задачу выполненной):
- Репозиторий переведён в монорепу (apps/frontend + apps/backend + packages/db).
- __tests__/ и vitest конфиги удалены, зависимости очищены, package-lock.json удалён.
- docker-compose поднимает Postgres + backend + frontend.
- Prisma миграции создают таблицы и ограничения; отдельные SQL-миграции создают триггеры/VIEW/функции/индексы.
- Есть seed, который генерирует 5000+ записей habit_checkins.
- Есть аудит через триггеры INSERT/UPDATE/DELETE.
- Есть триггер агрегатов habit_stats.
- Есть 2 функции (скалярная + табличная), 3 VIEW.
- Есть отчётные эндпойнты с параметризованным SQL.
- Есть batch-import эндпойнт с логированием ошибок.
- Swagger доступен и описывает API.
- Фронт больше не обращается к Supabase DB напрямую (никаких запросов в supabase-js ради данных).
- Секретов в репозитории нет, есть .env.example для корня/фронта/бэка.

Формат ответа в PLAN:
1) Сначала выдай пошаговый план с перечислением файлов/папок, которые будут созданы/изменены/удалены.
2) Затем начинай выполнять план последовательно.
3) На каждом шаге: кратко что изменилось + как проверить (команда/URL/endpoint).
